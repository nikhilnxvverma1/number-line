{"mappings":"AAAA,qDAAqD;AACrD;IACC;;;;OAIG;IACH,OAAO,EAAC,MAAM,EAAE,CAAC;IACjB,+EAA+E;IAC/E,YAAY,EAAC,MAAM,CAAC;IACpB;;;;OAIG;IACH,UAAU,EAAC,MAAM,CAAC;IAClB,gDAAgD;IAChD,oBAAoB,EAAC,MAAM,CAAC;IAC5B,gDAAgD;IAChD,oBAAoB,EAAC,MAAM,CAAC;IAC5B,4CAA4C;IAC5C,aAAa,EAAC,sBAAsB,CAAC;IACrC;;;;;;;OAOG;IACH,aAAa,CAAC,EAAC,MAAM,CAAC;IACtB;;;;OAIG;IACH,mBAAmB,CAAC,EAAC,MAAM,CAAC;IAC5B;;;OAGG;IACH,oBAAoB,CAAC,EAAC,MAAM,CAAC;IAC7B;;;OAGG;IACH,SAAS,CAAC,EAAC,MAAM,CAAC;IAClB;;;;;OAKG;IACH,YAAY,CAAC,EAAC,OAAO,CAAC;CACtB;AAGD;;;GAGG;AACH;gBAQ8B,QAAQ,EAAC,kBAAkB;IA2BxD;;;;;OAKG;IACH,YAAY,CAAC,UAAU,EAAE,MAAM;IAS/B;;;;OAIG;IACH,QAAQ,CAAC,UAAU,EAAC,MAAM,EAAC,QAAQ,EAAC,MAAM;IA6B1C;;;;;;OAMG;IACH,OAAO,CAAC,QAAQ,EAAC,MAAM,EAAC,SAAS,EAAC,OAAO,GAAE,MAAM;IAcjD;;;;;;;OAOG;IACH,UAAU,CAAC,KAAK,EAAC,MAAM,EAAC,SAAS,EAAC,OAAO,GAAE,MAAM;IASjD;;;;OAIG;IACH,cAAc,CAAC,MAAM,EAAC,MAAM,GAAE,mBAAmB;IA8EjD;;;OAGG;IACH,MAAM,CAAC,KAAK,EAAC,MAAM;IAInB;;;;;;;OAOG;IACH,UAAU,CAAC,KAAK,EAAC,MAAM,EAAC,iBAAiB,EAAC,MAAM,GAAE,OAAO;IAczD,IAAI,OAAO,IAAG,kBAAkB,CAE/B;IAED;;;;;OAKG;IACH,IAAI,aAAa,IAAG,MAAM,CAEzB;IAED;;;;OAIG;IACH,IAAI,YAAY,IAAG,MAAM,CAExB;IAED,yFAAyF;IACzF,IAAI,UAAU,IAAG,MAAM,CAEtB;IAED,oGAAoG;IACpG,IAAI,SAAS,IAAG,MAAM,CAErB;IAED,6EAA6E;IAC7E,IAAI,YAAY,IAAG,MAAM,CAExB;IAED,sFAAsF;IACtF,IAAI,UAAU,IAAG,MAAM,CAEtB;IAED,yEAAyE;IACzE,IAAI,SAAS,IAAG,MAAM,CAErB;IAED;;;OAGG;IACH,IAAI,UAAU,IAAG,MAAM,CAEtB;IAED,qCAAqC;IACrC,IAAI,SAAS,IAAG,MAAM,CAErB;IAED,iFAAiF;IACjF,IAAI,OAAO,IAAG,MAAM,CAEnB;CACD;AAED,+FAA+F;AAC/F;IACC;;;;;;;OAOG;IACH,QAAQ,CAAC,KAAK,EAAC,MAAM,EAAC,KAAK,EAAC,MAAM,EAAC,QAAQ,EAAC,MAAM,EAAC,UAAU,EAAC,UAAU,GAAE,MAAM,CAAC;CACjF;AAED;;;;;;;;GAQG;AACH,4BAA4B,CAAC,EAAC,MAAM,EAAC,CAAC,EAAC,MAAM,EAAC,CAAC,EAAC,MAAM,EAAC,CAAC,EAAC,MAAM,EAAC,CAAC,EAAC,MAAM,GAAE,MAAM,CAE/E;AAED,6DAA6D;AAC7D;IACC,oEAAoE;IACpE,MAAM,EAAC,MAAM,CAAC;IACd,wEAAwE;IACxE,aAAa,EAAC,MAAM,CAAA;IACpB,6BAA6B;IAC7B,GAAG,EAAC,MAAM,CAAC;IACX,6DAA6D;IAC7D,SAAS,EAAC,iBAAiB,EAAE,CAAC;IAC9B,0CAA0C;IAC1C,MAAM,EAAC,MAAM,CAAC;IACd,gDAAgD;IAChD,aAAa,EAAC,MAAM,CAAC;IACrB,8CAA8C;IAC9C,WAAW,EAAC,MAAM,CAAC;IACnB,4DAA4D;IAC5D,UAAU,EAAC,UAAU,CAAC;CACtB;AAED,2DAA2D;AAC3D;IACC,8DAA8D;IAC9D,MAAM,EAAC,MAAM,CAAC;IACd,sFAAsF;IACtF,KAAK,EAAC,MAAM,CAAC;IACb,8BAA8B;IAC9B,KAAK,EAAC,MAAM,CAAC;IACb,gDAAgD;IAChD,QAAQ,EAAC,MAAM,CAAC;CAChB","sources":["src/src/number-line.ts","src/number-line.ts"],"sourcesContent":[null,"/** Configurational description of the number line */\nexport interface INumberLineOptions{\n\t/**\n\t * The genesys pattern that needs to be repeated over\n\t * the course of the number line's length. Each item is a tick\n\t * that has a length. The array must have at least one item.\n\t */\n\tpattern:number[];\n\t/** Base value of the number line for the area covered by {@link baseLength} */\n\tbaseCoverage:number;\n\t/** \n\t * Length of the number line basis which all calculations are performed.\n\t * Note that the number line is virtually infinite but {@link baseLength}\n\t * along with {@link baseCoverage} governs the starting scale\n\t */\n\tbaseLength:number;\n\t/** The lower bound breakpoint for unit length*/\n\tbreakpointLowerbound:number;\n\t/** The upper bound breakpoint for unit length*/\n\tbreakpointUpperBound:number;\n\t/** The labelling strategy for tick marks */\n\tlabelStrategy:ITickMarkLabelStrategy;\n\t/** \n\t * A number (preferably close to 1) that governs how fast\n\t * the tick marks stretches upto {@link breakpointUpperBound} \n\t * before resetting back to the defined {@link breakpointLowerbound}. \n\t * The smaller the number the faster tick marks stretch. This number \n\t * must always be greater than 1\n\t * @default 1.3\n\t */\n\tstretchModulo?:number;\n\t/** \n\t * The initial displacement of the number line\n\t * with respect to the origin.\n\t * @default 0 \n\t */\n\tinitialDisplacement?:number;\n\t/** \n\t * The initial magnification of the number line.\n\t * @default 1 \n\t */\n\tinitialMagnification?:number;\n\t/** \n\t * The last value on the number line. Setting this value\n\t * means that the number line is bound.Optional.\n\t */\n\tfiniteEnd?:number;\n\t/** \n\t * Stretches the entire number line such that the first\n\t * value is the starting value and the last value is the\n\t * ending value. Requires {@link finiteEnd} to be set. \n\t * @default false\n\t */\n\tstretchToFit?:boolean;\n}\n\n\n/** \n * A stretchable, zoomable number line view model that can\n * be used to construct functional rulers and graphs \n */\nexport class NumberLine{\n\n\tprivate _displacement:number = 0;\n\tprivate _magnification:number = 1;\n\tprivate _unitLength:number = -1;\n\tprivate _unitValue:number = -1;\n\n\t\n\tconstructor(private readonly _options:INumberLineOptions){\n\t\tthis.initialize();\n\t}\n\n\tprivate initialize(){\n\t\tthis.options.initialDisplacement = this.options.initialDisplacement==undefined?0:this.options.initialDisplacement;\n\t\tthis.options.initialMagnification = this.options.initialMagnification==undefined?1:this.options.initialMagnification;\n\t\tif(this.options.initialMagnification==undefined){\n\t\t\tthis.options.initialMagnification = 1;\n\t\t}else if(this.options.initialMagnification<0){\n\t\t\tthrow new Error(\"Initial Magnfication can never be negative. Try a number between 0 and 1 if you want to zoom out\");\n\t\t}\n\t\tif(this.options.stretchModulo==undefined){\n\t\t\tthis.options.stretchModulo = 1.3;\n\t\t}else if(this.options.stretchModulo<=1){\n\t\t\tthrow new Error(\"Stretch modulo cannot be <=1\");\n\t\t}\n\t\tthis.options.stretchToFit = this.options.stretchToFit==undefined?false:this.options.stretchToFit;\n\t\t\n\t\tthis._magnification = this.options.initialMagnification;\n\t\tthis._displacement = this.options.initialDisplacement;\n\t\tthis.computeScale();\n\t\tif(this.options.stretchToFit && this.options.finiteEnd!=undefined){\n\t\t\tthis.stretchToFit(this.options.finiteEnd);\n\t\t}\n\t}\n\n\t/**\n\t * Stretches the entire number line such that the first\n\t * value is the starting value(0) and the last value is the\n\t * {@link finalValue}\n\t * @param finalValue The last value on the number line\n\t */\n\tstretchToFit(finalValue: number) {\n\t\tif(finalValue<=0){\n\t\t\tthrow new Error(\"Final value has to be positive. Consider using rangeFit instead\");\n\t\t}\n\t\tthis._displacement = 0;\n\t\tthis._magnification = this.baseCoverage / finalValue;\n\t\tthis.computeScale();\n\t}\n\n\t/**\n\t * Fits a range within the base length\n\t * @param startValue Smaller value\n\t * @param endValue Bigger value\n\t */\n\trangeFit(startValue:number,endValue:number){\n\t\tif(endValue<=startValue){\n\t\t\tthrow new Error(\"Ending value has to be greater than starting value\");\n\t\t}\n\t\tconst difference = endValue - startValue;\n\t\tthis.stretchToFit(difference);\n\t\tthis.moveBy(startValue*this.magnification);\n\t}\n\n\t/** \n\t * Internal method that must be called everytime there is a change in magnification,\n\t * so as to recompute unit length and unit value. Computes in O(1) time\n\t * */\n\tprivate computeScale(){\n\t\tconst repeater = 1 + this.magnification%this.options.stretchModulo;\n\t\tthis._unitLength = rangeMapper(\n\t\t\t\t\t\t\trepeater,\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tthis.options.stretchModulo+1,\n\t\t\t\t\t\t\tthis.options.breakpointLowerbound,\n\t\t\t\t\t\t\tthis.options.breakpointUpperBound);\n\n\t\tconst unitCount = this.baseLength / this._unitLength;\n\t\t// last value is unitCount * unit value\n\t\t// therefore, as magnification inversely divides last value\n\t\tthis._unitValue = this.baseCoverage/(this.magnification*unitCount);\n\t\t\n\t}\n\n\t/**\n\t * Computes the value at specified distance from origin in O(1) time\n\t * @param location Position along the number line\n\t * @param wrtOrigin True implies location is with respect to origin.\n\t * False gives location with respect to the assumed start.\n\t * @returns the value on the number line on that distance\n\t */\n\tvalueAt(location:number,wrtOrigin:boolean):number{\n\t\tthis.computeScale();\n\t\tif(wrtOrigin){\n\t\t\treturn (location/this.unitLength) * this.unitValue;\n\t\t}else{\n\t\t\t// find out value since left most point (origin)\n\t\t\tconst unitCount = location/this.unitLength;\n\t\t\tconst valueSinceOrigin = unitCount * this.unitValue;\n\t\t\t// find out the value of displacement\n\t\t\tconst valueOfDisplacement = (this.displacement/this.unitLength)*this.unitValue;\n\t\t\treturn valueOfDisplacement + valueSinceOrigin;\n\t\t}\n\t}\n\n\t/**\n\t * Computes and returns the location of the \n\t * given value along the number line\n\t * @param value value that rests at the number line\n\t * @param wrtOrigin True implies location is with respect to origin.\n\t * False gives location with respect to the assumed start.\n\t * @returns The location of this value w.r.t origin\n\t */\n\tlocationOf(value:number,wrtOrigin:boolean):number{\n\t\tthis.computeScale();\n\t\tif(wrtOrigin){\n\t\t\treturn (value/this.unitValue) * this.unitLength;\n\t\t}else{\n\t\t\treturn (value/this.unitValue) * this.unitLength - this.displacement;\n\t\t}\n\t}\n\n\t/** \n\t * Builds a view model describing this number line \n\t * @returns A view model useful for rendering this number line\n\t * through any rendering technology or format\n\t */\n\tbuildViewModel(length:number):NumberLineViewModel{\n\t\tthis.computeScale();\n\t\t\n\t\tconst tickGap = this.tickGap;\n\t\tconst unitLength = this.unitLength;\n\t\tconst unitValue= this.unitValue;\n\t\tconst tickValue= unitValue/this.tickCount;\n\t\t\n\t\tlet firstTickMarkValue:number;\n\t\tlet firstTickMarkIndex:number;\n\t\tlet firstTickMarkPosition:number;\n\t\tlet totalNegativeTicks:number;\n\t\tif(this.displacement>=0){\n\t\t\tconst tickCountsTillFirstTick = Math.ceil((this.displacement/unitLength)*this.tickCount)\n\t\t\tfirstTickMarkValue = tickCountsTillFirstTick*tickValue;\n\t\t\tfirstTickMarkIndex = tickCountsTillFirstTick % this.tickCount;\n\t\t\tfirstTickMarkPosition = tickCountsTillFirstTick*tickGap - this.displacement;\n\t\t\ttotalNegativeTicks = 0;\n\t\t}else{\n\t\t\tconst tickCountsTillFirstTick = Math.floor((-this.displacement/unitLength)*this.tickCount)\n\t\t\ttotalNegativeTicks = tickCountsTillFirstTick;\n\t\t\tfirstTickMarkValue = -tickCountsTillFirstTick*tickValue;\n\t\t\tfirstTickMarkIndex = this.tickCount - tickCountsTillFirstTick % this.tickCount - 1;\n\t\t\tfirstTickMarkPosition = tickCountsTillFirstTick*tickGap - this.displacement;\n\t\t}\n\n\t\tconst totalTicks = Math.floor((length - firstTickMarkPosition)/tickGap);\n\t\tconst leftoverSpace = length - totalTicks*tickGap;\n\n\t\tconst numberLineViewModel:NumberLineViewModel = {\n\t\t\toffset:firstTickMarkPosition,\n\t\t\tleftoverSpace:leftoverSpace,\n\t\t\tstartingValue:this.firstValue,\n\t\t\tendingValue:this.valueAt(length,false),\n\t\t\tlength:length,\n\t\t\tnumberLine:this,\n\t\t\ttickMarks:[],\n\t\t\tgap:tickGap\n\t\t}\n\n\t\t\n\t\tfor (let i = 0,\n\t\t\tcurrentTickValue = firstTickMarkValue,\n\t\t\tcurrentTickPosition = firstTickMarkPosition,\n\t\t\tcurrentTickIndex = firstTickMarkIndex,\n\t\t\tnegativeTicksLeft = totalNegativeTicks\n\t\t\t; i < totalTicks;\n\t\t\ti++,\n\t\t\tcurrentTickValue+=tickValue,\n\t\t\tcurrentTickPosition+=tickGap,\n\t\t\tnegativeTicksLeft--\n\t\t\t) {\n\n\t\t\t\tconst tickMarkViewModel:TickMarkViewModel={\n\t\t\t\t\tvalue:currentTickValue,\n\t\t\t\t\tposition:currentTickPosition,\n\t\t\t\t\theight:this.options.pattern[currentTickIndex],\n\t\t\t\t\tlabel:this.options.labelStrategy!=null?\n\t\t\t\t\t\tthis.options.labelStrategy.labelFor(\n\t\t\t\t\t\t\tcurrentTickValue,\n\t\t\t\t\t\t\tcurrentTickIndex,\n\t\t\t\t\t\t\tcurrentTickPosition,\n\t\t\t\t\t\t\tthis):\n\t\t\t\t\t\t\tnull\n\t\t\t\t}\n\t\t\t\tnumberLineViewModel.tickMarks.push(tickMarkViewModel);\n\t\t\t\tconst indexIncrementer = negativeTicksLeft>0?-1:1;\n\t\t\t\tcurrentTickIndex+=indexIncrementer;\n\t\t\t\tif(currentTickIndex<0){\n\t\t\t\t\tcurrentTickIndex=this.tickCount-1;\n\t\t\t\t}else if(currentTickIndex>=this.tickCount){\n\t\t\t\t\tcurrentTickIndex = 0;\n\t\t\t\t}\n\t\t}\n\n\t\treturn numberLineViewModel;\n\t}\n\n\t/** \n\t * Moves the ruler by a specified amount\n\t * @param delta The amount to move by. Value can be either positive or negative\n\t */\n\tmoveBy(delta:number){\n\t\tthis._displacement+=delta;\n\t}\n\n\t/**\n\t * Magnifies the entire ruler either in or out\n\t * @param delta The amount to magnify by (+ve or -ve)\n\t * @param positionFromStart The position on the number line which\n\t * should not move because thats whats being zoomed around.\n\t * This position is relative to the start of the number line\n\t * @returns True if zoom was successful, false if zoom was out of range\n\t */\n\tzoomAround(delta:number,positionFromStart:number):boolean{\n\t\tif(this._magnification+delta<=0){\n\t\t\treturn false;\n\t\t}\n\t\tconst fixedValue = this.valueAt(positionFromStart,false);\n\t\t// const beforeZoom = this.locationOf(fixedValue);\n\t\tthis._magnification+=delta;\n\t\tthis.computeScale();\n\t\tconst afterZoom = this.locationOf(fixedValue,false);\n\t\tconst cancelDifference = afterZoom - positionFromStart;\n\t\tthis.moveBy(cancelDifference);\n\t\treturn true;\n\t}\n\n\tget options():INumberLineOptions{\n\t\treturn this._options;\n\t}\n\n\t/**\n\t * A factor that governs the scale of the number line.\n\t * When magnification==1, you are in the base case.\n\t * When magnification>1, you aer zooming out.\n\t * When magnification is b/w 0 and 1, you are zooming in. \n\t */\n\tget magnification():number{\n\t\treturn this._magnification;\n\t}\n\n\t/** \n\t * The displacement of origin w.r.t the assumed\n\t * starting point of the number line. This can also\n\t * be thought of as offset. \n\t */\n\tget displacement():number{\n\t\treturn this._displacement;\n\t}\n\n\t/** The first value on the number line based on length, displacement and magnification */\n\tget firstValue():number{\n\t\treturn this.valueAt(0,false);\n\t}\n\n\t/** The last value on the number line based on {@link baseLength}, displacement and magnification */\n\tget lastValue():number{\n\t\treturn this.valueAt(this.baseLength,false);\n\t}\n\n\t/** Base final value for magnificaiton = 1, displacement=0 for base length */\n\tget baseCoverage():number{\n\t\treturn this.options.baseCoverage;\n\t}\n\n\t/** Length of each unit based on current magnification, lower and upper breakpoints */\n\tget unitLength():number{\n\t\treturn this._unitLength;\n\t}\n\n\t/** Value of each unit based on magnification and base value of a unit */\n\tget unitValue():number{\n\t\treturn this._unitValue;\n\t}\n\n\t/** \n\t * Shortcut for getting the basis length of the number line,\n\t * w.r.t which all calculations are performed \n\t */\n\tget baseLength():number{\n\t\treturn this.options.baseLength;\n\t}\n\n\t/** Number of tick marks in a unit */\n\tget tickCount():number{\n\t\treturn this.options.pattern.length;\n\t}\n\n\t/** The gap between ticks in a unit. This is based on the length of each unit. */\n\tget tickGap():number{\n\t\treturn this._unitLength/this.tickCount;\n\t}\n}\n\n/** Configurable callback to let the user of NumberLine to define their own tick mark labels */\nexport interface ITickMarkLabelStrategy{\n\t/**\n\t * Callback for getting the tick mark label for each unit.\n\t * @param value Value of this tick mark\n\t * @param index Index of this tick mark in the tick mark pattern\n\t * @param position The position of this tick mark w.r.t start\n\t * @param numberLine The main number line requesting the label\n\t * @returns The formatted tick mark label. Return null for blank tick marks.\n\t */\n\tlabelFor(value:number,index:number,position:number,numberLine:NumberLine):string;\n}\n\n/**\n * Linearly maps a number from the first range to the second range\n * @param x number lying between a and b\n * @param a lowerbound of first range\n * @param b upperbound of first range\n * @param c lowerbound of second range\n * @param d upperbound of second range\n * @returns number between {@link c} and {@link d} as a result of linear mapping\n */\nexport function rangeMapper(x:number,a:number,b:number,c:number,d:number):number{\n\treturn ((x-a)/(b-a))*(d-c) + c;\n}\n\n/** ViewModel that describes what a number line looks like */\nexport interface NumberLineViewModel{\n\t/** The gap at the start of number line before a tick mark begins */\n\toffset:number;\n\t/** The trailing space left between the last tick mark and the length */\n\tleftoverSpace:number\n\t/** Gap between tick marks */\n\tgap:number;\n\t/** Array of tick marks over the length of this view model */\n\ttickMarks:TickMarkViewModel[];\n\t/** The length of this ruler view model */\n\tlength:number;\n\t/** The value at the start of the number line */\n\tstartingValue:number;\n\t/** The value at the end of the number line */\n\tendingValue:number;\n\t/** The number line for which this view model was created */\n\tnumberLine:NumberLine;\n}\n\n/** ViewModel that describes what a tick mark looks like */\nexport interface TickMarkViewModel{\n\t/** Height of the tick as governed by the tick mark pattern */\n\theight:number;\n\t/** Label on the tick mark as directly received from {@link ITickMarkLabelStrategy} */\n\tlabel:string;\n\t/** Value of this tick mark */\n\tvalue:number;\n\t/** Position of this tick mark from the start */\n\tposition:number;\n}"],"names":[],"version":3,"file":"number-line.d.ts.map"}